# G9-Ragebait

Projektbeschreibung

Vielen Menschen wird folgende Situation bekannt vorkommen: Man öffnet eine Social Media Plattform und neben vielen unterhaltsamen Inhalten, werden einem auch ein paar ausgespielt, welche ihrem Geschmack nicht treffen. Das ist normal und gehört für viele zum Alltag. Doch das Entscheidende ist die darauffolgende Handlung. Wird der Post übersprungen? Oder bewertet der Nutzende ihn negativ? Vielleicht wird sogar ein beleidigender Kommentar verfasst. Bei vielen Algorithmen ist es unwichtig ob mit dem Inhalt auf positive oder negative Weise interagiert wird. Bei häufiger Interaktion wird der Post mehr Menschen ausgespielt. Dies führt dazu, dass manche Content Creator absichtlich Inhalte veröffentlichen, von denen sie, bereits im Vorfeld, wissen, dass viele ihrer Zuschauer sich darüber beschweren und Kommentare schreiben werden. Dann spricht man von Rage Bait – dem Thema unseres Projekts. Es wurde entwickelt, um Nutzende dazu zu bringen, über den Einfluss von Social Media Inhalten auf ihre Stimmung nachzudenken. Dabei handelt es sich um eine interaktive Abstimmungs- und Visualisierungsanwendung, die speziell für den HoloTower unserer Schule entwickelt wurde. Sie eignet sich besonders gut für den Einsatz bei Ausstellungen, Messen oder Tagen der offenen Tür.

Nutzungsanleitung

Nutzungsanleitung Nach dem Start sieht der Nutzende zunächst einen Slider sowie einen Post, der als Hologramm dargestellt wird. Über dem Slider befindet sich der Text „This post gives me … feelings“. Links neben dem Slider steht das Wort „negative“, ergänzt durch einen wütenden Smiley. Rechts befindet sich das Wort „positive“ mit einem glücklichen Smiley darunter. Mit Hilfe des Sliders kann der Nutzende angeben, welche Gefühle der gezeigte Post bei ihm auslöst. Die Steuerung erfolgt über Makey Makey. Um den Slider nach rechts zu bewegen, wird ein leitfähiges Objekt in der Form eines Herzens bzw die "A" Taste gedrückt. Um den Slider nach links zu bewegen, muss gegen einen Sandsack getreten bzw die "D" Taste gedrückt werden. Bleibt der Slider für einige Sekunden unverändert, erscheint ein Countdown-Timer, der bei 5 Sekunden startet. Läuft der Timer ab, wird die Eingabe des Nutzenden gespeichert. Anschließend wechselt die Ansicht und der Nutzende sieht eine grafische Darstellung, die zeigt, wie andere Personen auf denselben Post reagiert haben.

Anmerkung Die letzte Version konnte nicht mit Makey Makey getestet werden, da nicht vorhanden

Einzelne Features und Aufgabenteilung

Kommentare/Martin

Erstellen der Graphischen Darstellung von Kommentaren. Erstellen eines Systems in welchen man Kommentar Info eingeben kann. Erstellen eines Systems welches Kommentare zufällig anordnet Schreiben der Kommentare Erstellen Profilbilder Zusammenfügen der 3 Projekte Erstellen der "Build" Szene GameObjects in Prefabs erstellen Editieren der Skripte für Funktion in einer Szene (zusammenarbeit der Systeme) Erstellen eines Skriptes welches die Graphischen Gameobjecte Aktiviert/Deaktiviert (Manager)

Slider-Szene/Kinzy Pointinger

A. SliderController In diesem Script programmierte Kinzy die Steuerung des Sliders über Tastatureingaben (A → links, D → rechts). Jede Bewegung verändert die Position des Reglers um einen festen Schritt innerhalb eines definierten Bereichs (der Länge der ScrollBar). Die Schrittzahl ist entscheidend für die anschließende Verarbeitung der Abstimmung.

B. SliderColor Kinzy implementierte eine Farbinterpolation mit einem Gradient, um die Farbe des Sliders dynamisch an seine aktuelle Position anzupassen. Dadurch erhält der Nutzer eine visuelle Rückmeldung über seine Auswahl.

C. TimerController Dieses Script überprüft in Echtzeit, ob der Nutzer den Slider innerhalb einer bestimmten Zeit bewegt hat. Erfolgt in diesem Zeitraum keine Eingabe, startet automatisch ein Countdown. Nach Ablauf wird die aktuelle Slider‑Position als Abstimmung an den VoteManager übergeben, und danach wird die Auswertungsszene geladen. Auch diese Funktion wurde von Kinzy umgesetzt.

D. CountdownUi Kinzy entwickelte eine eigene Countdown‑Komponente, die über ein TextMeshPro‑UI‑Element eine visuelle Rückmeldung gibt. Der Nutzer sieht die verbleibende Zeit bis zur Speicherung seiner Abstimmung. Der Countdown läuft als Coroutine und ruft nach Ablauf eine Callback‑Methode auf.

E. VoteManager Kinzy programmierte den VoteManager, der die gesamte Abstimmungslogik verwaltet. Er speichert die abgegebenen Stimmen in einem Integer‑Array, begrenzt Eingaben auf den Bereich von –5 bis +5 und nutzt PlayerPrefs, um die Votes dauerhaft zu speichern und auch nach Szenenwechseln beizubehalten.

Grafische Darstellung/Caterina: Projektbeitrag: Entwicklung des interaktiven Abstimmungs-Diagramms Caterina hat die technische die Visualisierung der Benutzerabstimmungen ("How other Users voted") entwickelt. Sie war dafür verantwortlich, die Rohdaten in eine klare, proportionale grafische Darstellung zu übersetzen und das UI-Layout stabil zu halten.

A. Dynamische Visualisierung der Abstimmungsergebnisse (BarManager.cs) Caterina entwickelte die Logik, mit der die kleinen farbigen Balken über der Skala (von -5 bis 5) generiert und skaliert werden: • Datenbasierte Skalierung: Sie implementierte eine Funktion, die die Höhe der Balken (z. B. bei den Werten -4, 2 und 3 im Bild) proportional zu den Abstimmungswerten berechnet. • Wachstumsrichtung: Durch die programmatische Setzung des Pivot-Punkts auf die Unterkante (0.5, 0) stellte sie sicher, dass die Balken korrekt von der schwarzen Basislinie nach oben wachsen. • Stabile Positionierung: Sie fixierte die Ankerpunkte der Balken an der Basis, damit diese auch bei einer Änderung der Diagrammgröße präzise auf der horizontalen Achse verankert bleiben. Berechnung der Balkenhöhe: Caterina nutzt eine mathematische Formel, um die Höhe der UI-Balken zu bestimmen. Dabei wird der Eingabewert (values[i]) durch 10 geteilt und mit einer maximalen Höhe von 200 Einheiten multipliziert. Das bedeutet: Ein Wert von 10 entspricht der vollen Höhe von 200 Pixeln. • Festlegung des Wachstumspunkts (Pivot): Sie setzt den Pivot-Punkt jedes Balkens programmatisch auf (0.5, 0). Dies ist entscheidend, damit sich die Balken beim Ändern der Höhe von der Grundlinie nach oben ausdehnen, anstatt von der Mitte aus in beide Richtungen zu wachsen. • Anpassung der Grafik (sizeDelta): Caterina verändert gezielt nur die Y-Komponente der sizeDelta, während die Breite der Balken (X-Achse) unverändert bleibt. Dadurch behalten alle Balken ihre einheitliche Dicke, während sie unterschiedliche Höhen einnehmen. • Horizontale Verankerung: Das Skript setzt die vertikalen Ankerpunkte (anchorMin.y und anchorMax.y) auf Null. Dies stellt sicher, dass alle Balken fest auf der unteren Basislinie des Diagramms stehen bleiben, unabhängig davon, wie groß das Fenster ist. • Sicherheitsabfrage (Schleife): Die for-Schleife ist so programmiert, dass sie nur so viele Balken aktualisiert, wie sowohl Bild-Objekte im Array als auch Datenwerte vorhanden sind. Dies verhindert Fehlermeldungen (Index-Fehler), falls die Anzahl der Daten nicht exakt mit der Anzahl der Balken übereinstimmt. • Datenabruf: Über den Befehl VoteManager.Instance.GetAllVotes() greift das Skript auf die aktuelle Datenbank der Nutzer-Abstimmungen zu und speichert diese in einem Array (currentVotes). • Visuelle Aktualisierung: Im letzten Schritt übergibt Caterina diese frischen Daten an die zuvor beschriebene Methode UpdateChart(currentVotes). Dadurch werden die Balken im Diagramm (wie im Bild zu sehen) sofort an die neuen Zahlen angepasst.

Übergang zur Input-Szene (Ablaufsteuerung) Zusätzlich zur visuellen Darstellung bereitete Caterina den zeitgesteuerten Übergang vor: • User-Feedback-Loop: Nach der Anzeige der Wahlergebnisse (wie im Screenshot durch den Timer "Return in: 15s" angedeutet) kehrt das System automatisch zur Input-Szene zurück. • Prozessfluss: Caterina stellte sicher, dass die Diagramm-Daten nach Ablauf der Zeit bereinigt werden, sodass das System für die nächste Eingabe bereit ist und der Nutzer nahtlos zwischen der Stimmabgabe und der Ergebnisansicht wechseln kann.

B. Layout-Struktur der Koordinatenachse (Anchor.cs) Um das Diagramm für verschiedene Bildschirmauflösungen robust zu machen, implementierte Caterina eine automatisierte Anker-Steuerung: • Achsen-Ausrichtung: Sie entwickelte ein Skript, das die schwarze Hauptachse sowie die Markierungen automatisch im UI zentriert. • Präzise Platzierung: Durch die Justierung der anchoredPosition stellte sie sicher, dass die Achse exakt an der gewünschten vertikalen Position im unteren Drittel des Bildschirms fixiert bleibt.

C. Steuerung der Skalen-Beschriftung (XAxisLabels.cs) Caterina war für die dynamische Anordnung der Zahlenwerte (-5 bis 5) unterhalb der Hauptachse verantwortlich: • Zentrale Justierung: Sie erstellte ein System, mit dem der vertikale Abstand aller Zahlenbeschriftungen zur Achse über einen einzigen Parameter (xNumbers) gesteuert werden kann. • Dynamische Synchronisation: Die Logik stellt sicher, dass die Textfelder (TextMeshPro) in jedem Frame korrekt zur Achse ausgerichtet werden, was eine saubere und lesbare Skalierung unter den jeweiligen Balken garantiert.
